<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-12-15 Sun 23:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tarot</title>
<meta name="author" content="Jordan Bell" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Tarot</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org86566d1">1. Planning</a>
<ul>
<li><a href="#orgbb83513">1.1. Tasks</a>
<ul>
<li><a href="#org1019c8b">1.1.1. <span class="done DONE">DONE</span> Adopt Tarot code into literate source <code>[100%]</code></a></li>
<li><a href="#org7c8fa35">1.1.2. <span class="todo TODO">TODO</span> Package Tarot for Guix consumption</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgaed8521">2. Source</a>
<ul>
<li><a href="#orga635d20">2.1. Cards</a>
<ul>
<li><a href="#org0ed1e6f">2.1.1. Minor Arcana</a></li>
<li><a href="#org6fbff8d">2.1.2. Major Arcana</a></li>
<li><a href="#orgfcd00ce">2.1.3. Tarot Cards</a></li>
</ul>
</li>
<li><a href="#org8a94b6c">2.2. Randomness</a>
<ul>
<li><a href="#org7182993">2.2.1. Individual Cards</a></li>
<li><a href="#org45d3cc6">2.2.2. Lists</a></li>
</ul>
</li>
<li><a href="#org3da6cdb">2.3. Main</a></li>
</ul>
</li>
<li><a href="#org247abf8">3. Afterword</a></li>
</ul>
</div>
</div>
<p>
Tarot is quick, but thorough project for dealing with Tarot cards. Using Haskell&rsquo;s powerful type system, we can build a project that effectively describes what Tarot <i>is</i> more than how to use it. It makes for an intuitive way of handling Tarot cards, and is easily extensible.
</p>
<div id="outline-container-org86566d1" class="outline-2">
<h2 id="org86566d1"><span class="section-number-2">1.</span> Planning</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgbb83513" class="outline-3">
<h3 id="orgbb83513"><span class="section-number-3">1.1.</span> Tasks</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-org1019c8b" class="outline-4">
<h4 id="org1019c8b"><span class="section-number-4">1.1.1.</span> <span class="done DONE">DONE</span> Adopt Tarot code into literate source <code>[100%]</code></h4>
<div class="outline-text-4" id="text-1-1-1">
</div>
<ol class="org-ol">
<li><a id="org38750bb"></a><span class="done DONE">DONE</span> Adopt minor arcana types into literate source<br /></li>
<li><a id="orgbca1f6e"></a><span class="done DONE">DONE</span> Adopt major arcana types into literate source<br /></li>
<li><a id="org82d627d"></a><span class="done DONE">DONE</span> Refactor minor and major arcana into Tarot type<br /></li>
<li><a id="org01d46ad"></a><span class="done DONE">DONE</span> Use TemplateHaskell for creating Uniform instances<br /></li>
<li><a id="orgabbd956"></a><span class="done DONE">DONE</span> Adopt Tarot project file into literate source<br /></li>
</ol>
</div>
<div id="outline-container-org7c8fa35" class="outline-4">
<h4 id="org7c8fa35"><span class="section-number-4">1.1.2.</span> <span class="todo TODO">TODO</span> Package Tarot for Guix consumption</h4>
</div>
</div>
</div>
<div id="outline-container-orgaed8521" class="outline-2">
<h2 id="orgaed8521"><span class="section-number-2">2.</span> Source</h2>
<div class="outline-text-2" id="text-2">
<p>
For the most part, the pursuit of this project is to attempt a simple project for practicing three major programming styles: Type-Driven Development, Algebra-Driven Development, and Literate Programming. I believe Tarot lends itself well to the first, Org to the last, and Haskell to all three. Still, this is a new venture for me: expect warts ahead, even if only in style.
</p>
</div>
<div id="outline-container-orga635d20" class="outline-3">
<h3 id="orga635d20"><span class="section-number-3">2.1.</span> Cards</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Tarot cards are pretty simple: they&rsquo;re just playing cards at the end of the day. Defining them is easy by using a type-system, more so with the power of Haskell&rsquo;s type system. For that, we can start from the bottom, and define basic value types that we&rsquo;ll use to construct a more complex relationship from later on, especially with respect to randomness. For now, we&rsquo;ll just define the cards.
</p>

<p>
Under Tarot, there are two systems of cards: minor and major arcana. The minor arcana are closer to the standard playing cards known by most people, while the major arcana are singular, simple concepts. Both lend themselves well to good ol&rsquo; type calculus, hence the use of Haskell.
</p>
</div>
<div id="outline-container-org0ed1e6f" class="outline-4">
<h4 id="org0ed1e6f"><span class="section-number-4">2.1.1.</span> Minor Arcana</h4>
<div class="outline-text-4" id="text-2-1-1">
</div>
<ol class="org-ol">
<li><a id="org31364ed"></a>Ranks<br />
<div class="outline-text-5" id="text-2-1-1-1">
<p>
Minor arcana are more-or-less like a standard deck of playing cards, with the only difference from my neck of the woods being that the Jack is replaced by the Paige and Knight. We&rsquo;ll lay them out in one basic sum type called Rank, ordered by ascending value:
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgfe5e5b0"><span style="color: #9ca0b0; font-style: italic;">{- | 'Rank' defines the 14 possible ranks of the minor arcana,</span>
<span style="color: #9ca0b0; font-style: italic;"> - 10 pip cards and 4 court/face cards.</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #8839ef;">data</span> <span style="color: #df8e1d;">Rank</span>
  <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">Ace</span>   <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Two</span>    <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Three</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Four</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Five</span>
  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Six</span>   <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Seven</span>  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Eight</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Nine</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Ten</span>
  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Paige</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Knight</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Queen</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">King</span>
  <span style="color: #9ca0b0; font-style: italic;">-- | Ranks are bounded, sequenced, finite, and have uniform distribution.</span>
  <span style="color: #9ca0b0; font-style: italic;">-- Deriving these classes allow us to have type-level functions for getting random elements,</span>
  <span style="color: #9ca0b0; font-style: italic;">-- a theme we'll repeat with other typeclasses.</span>
  <span style="color: #8839ef;">deriving</span> (<span style="color: #8839ef;">Bounded</span>, <span style="color: #8839ef;">Enum</span>, <span style="color: #8839ef;">Eq</span>, <span style="color: #8839ef;">Ord</span>, <span style="color: #8839ef;">Show</span>, <span style="color: #8839ef;">Generic</span>, <span style="color: #8839ef;">Finite</span>, <span style="color: #8839ef;">Uniform</span>)
</pre>
</div>

<p>
If you&rsquo;re familiar with Haskell, you can intuit why we&rsquo;d derive the basic typeclasses seen here for Ranks:
</p>

<dl class="org-dl">
<dt>Bounded</dt><dd>Ranks have maximum and minimum values, making them bounded. This will be useful for list comprehensions, where we can rely on the min and max Ranks to set limits for the cards.</dd>
<dt>Enum</dt><dd>Ranks have sequence, so they are enumerable. This will also work well with list comprehensions, but is also <b>very</b> important for our randomization.</dd>
<dt>Eq</dt><dd>Ranks can be equal, and checking equality will be necessary for card comparison.</dd>
<dt>Ord</dt><dd>Ranks have increasing value, with <code>Two</code> being greater than <code>One</code>, also good for card comparison.</dd>
<dt>Show</dt><dd>Displaying a Rank would just show its name, so the <b>Show</b> typeclass is a perfect fit.</dd>
</dl>

<p>
These are obvious uses, but we should note the power in the combination of <b>Bounded</b> and <b>Enum</b>: using them together indicates that our type has a floor and ceiling, as well as sequencing. We&rsquo;ll see the power of this in a bit.
</p>

<p>
The next typeclass, <b>Generic</b>, is special: it&rsquo;s used to allow us to morph the values of any given datatype into some values of another typeclass. For our usage, we&rsquo;ll want to do this for the remaining two typeclasses: <b>Finite</b> and <b>Uniform</b>. We&rsquo;ll also need a special language pragma to use
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #df8e1d;">{-# LANGUAGE DeriveAnyClass #-}</span>
</pre>
</div>

<p>
to unlock its full power, though; it allows us to make use of all the power of generic programming for our derived random functions.
</p>

<p>
Speaking of which, <b>Finite</b> and <b>Uniform</b> are typeclasses provided by the random package under <span class="underline">System.Random.Stateful</span>, and using it allows us to use type-level shenanigans to handle our random selection of cards. This is where our definitions of <b>Bounded</b> and <b>Enum</b> come in handy: since we&rsquo;ve defined our type such that its both enumerated and bound, we have the minimal required definitions to allow the compiler to derive the necessary functions for <b>Uniform</b> and <b>UniformRange</b>, typeclasses that will automatically figure out how to randomize our results.
</p>

<p>
This is because we defined <b>Rank</b> in terms that imply uniform and finite distribution, which we can generically derive functions for grabbing random values for. Now that we know the names and meanings, we can look over a simple example:
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgdf0769a"><span style="color: #8839ef;">import</span> <span style="color: #8839ef;">System.Random.Stateful</span>

<span style="color: #9ca0b0;">-- </span><span style="color: #9ca0b0; font-style: italic;">Tell the compiler to give us a random value for Rank from rng</span>
<span style="color: #1e66f5;">uniformM</span> globalStdGen <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #df8e1d;">Rank</span>
</pre>
</div>
</div>
</li>
<li><a id="org897a643"></a>Suits<br />
<div class="outline-text-5" id="text-2-1-1-2">
<p>
Minor arcana also have suits like most basic playing cards, though they are more esoteric. This will follow the same procedure as with Ranks:
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org03bf453"><span style="color: #9ca0b0; font-style: italic;">-- | 'Suit' defines the possible suits for the minor arcana.</span>
<span style="color: #8839ef;">data</span> <span style="color: #df8e1d;">Suit</span> <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">Wands</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Cups</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Swords</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Pentacles</span>
  <span style="color: #8839ef;">deriving</span> (<span style="color: #8839ef;">Bounded</span>, <span style="color: #8839ef;">Enum</span>, <span style="color: #8839ef;">Eq</span>, <span style="color: #8839ef;">Show</span>, <span style="color: #8839ef;">Generic</span>, <span style="color: #8839ef;">Finite</span>, <span style="color: #8839ef;">Uniform</span>)
</pre>
</div>

<p>
<b>NOTE:</b> We&rsquo;ve used both <b>Bounded</b> and <b>Enum</b> here, but not <b>Ord</b>. <b>Ord</b> is what tells us that one value is greater or lesser than another, which <b>does not hold for Suits</b>. They are neither greater or lesser, only equal, and only enumerated / sequential.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org6fbff8d" class="outline-4">
<h4 id="org6fbff8d"><span class="section-number-4">2.1.2.</span> Major Arcana</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
The Tarot major arcana are actually simpler than the minor, since they don&rsquo;t have two parts, just one. This will be a simple sum type as well, with some familiar instance definitions as well:
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orga3aa11c"><span style="color: #9ca0b0; font-style: italic;">-- | 'MajorArcana' defines the 22 major arcana.</span>
<span style="color: #8839ef;">data</span> <span style="color: #df8e1d;">MajorArcana</span>
  <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">TheFool</span>        <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheMagician</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheHighPriestess</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheEmpress</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheEmperor</span>
  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheHierophant</span>  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheLovers</span>   <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheChariot</span>       <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Strength</span>   <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheHermit</span>
  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">WheelOfFortune</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Justice</span>     <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheHangedMan</span>     <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Death</span>      <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Temperance</span>
  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheDevil</span>       <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheTower</span>    <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheStar</span>          <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheMoon</span>    <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheSun</span>
  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Judgement</span>      <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheWorld</span>
  <span style="color: #8839ef;">deriving</span> (<span style="color: #8839ef;">Eq</span>, <span style="color: #8839ef;">Enum</span>, <span style="color: #8839ef;">Show</span>, <span style="color: #8839ef;">Bounded</span>, <span style="color: #8839ef;">Generic</span>, <span style="color: #8839ef;">Finite</span>, <span style="color: #8839ef;">Uniform</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfcd00ce" class="outline-4">
<h4 id="orgfcd00ce"><span class="section-number-4">2.1.3.</span> Tarot Cards</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
With this, we can build constructors for our cards. They have two varieties, major and minor, and we&rsquo;ll construct a new type for holding those values:
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org76f3c0f"><span style="color: #9ca0b0; font-style: italic;">{- | 'Tarot' has two kinds, for minor and major arcana, as well as a bool for</span>
<span style="color: #9ca0b0; font-style: italic;"> - representing when the card is reversed.</span>
<span style="color: #9ca0b0; font-style: italic;"> - 'Minor' has rank, suit, and reversed status.</span>
<span style="color: #9ca0b0; font-style: italic;"> - 'Major' has the major arcana and the reversed status.</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #8839ef;">data</span> <span style="color: #df8e1d;">Tarot</span>
  <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">MinorCard</span> <span style="color: #8839ef;">Rank</span> <span style="color: #8839ef;">Suit</span> <span style="color: #8839ef;">Bool</span>
  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">MajorCard</span> <span style="color: #8839ef;">MajorArcana</span> <span style="color: #8839ef;">Bool</span>
  <span style="color: #8839ef;">deriving</span> (<span style="color: #8839ef;">Eq</span>, <span style="color: #8839ef;">Generic</span>, <span style="color: #8839ef;">Finite</span>, <span style="color: #8839ef;">Uniform</span>)
</pre>
</div>

<p>
This simple part mirrors what we&rsquo;ve already done with the rest of our types, but it does lack some of our commonly used typeclasses. We still need to define some rules for <b>Bounded</b> and <b>Enum</b>, but we can&rsquo;t actually derive the automatically here: the types are no longer basic sum types, but are now product types, and the compiler doesn&rsquo;t know the order they&rsquo;re enumerated or bound in. For that matter, we&rsquo;ll have to define the instance ourselves:
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgd630225"><span style="color: #9ca0b0; font-style: italic;">{- | Enumeration rules for tarot cards:</span>
<span style="color: #9ca0b0; font-style: italic;"> - Minor Arcana =&gt; 14 Ranks * 4 Suits * 2 Reversed states = 112 values</span>
<span style="color: #9ca0b0; font-style: italic;"> - Major Arcana =&gt; 22 arcana * 2 Reversed states = 44 values</span>
<span style="color: #9ca0b0; font-style: italic;"> - total: 156</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #8839ef;">instance</span> <span style="color: #df8e1d;">Enum</span> <span style="color: #df8e1d;">Tarot</span> <span style="color: #8839ef;">where</span>
  toEnum index
    <span style="color: #04a5e5;">|</span> index <span style="color: #04a5e5;">&lt;</span> <span style="color: #fe640b;">0</span> <span style="color: #04a5e5;">||</span> <span style="color: #fe640b;">156</span> <span style="color: #04a5e5;">&lt;=</span> index <span style="color: #04a5e5;">=</span> error <span style="color: #40a02b;">"Out of bounds for Tarot cards"</span>
    <span style="color: #04a5e5;">|</span> index <span style="color: #04a5e5;">&lt;</span> <span style="color: #fe640b;">112</span> <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">MinorCard</span> (toEnum rank) (toEnum suit) (toEnum reversed)
    <span style="color: #04a5e5;">|</span> <span style="color: #fe640b;">112</span> <span style="color: #04a5e5;">&lt;=</span> index <span style="color: #04a5e5;">&amp;&amp;</span> index <span style="color: #04a5e5;">&lt;</span> <span style="color: #fe640b;">134</span> <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">MajorCard</span> (toEnum arcana) <span style="color: #8839ef;">False</span>
    <span style="color: #04a5e5;">|</span> otherwise <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">MajorCard</span> (toEnum arcana) <span style="color: #8839ef;">True</span>
    <span style="color: #8839ef;">where</span>
      (index', rank) <span style="color: #04a5e5;">=</span> index <span style="color: #04a5e5;">`divMod`</span> <span style="color: #fe640b;">14</span>
      (reversed, suit) <span style="color: #04a5e5;">=</span> index' <span style="color: #04a5e5;">`divMod`</span> <span style="color: #fe640b;">4</span>
      arcana <span style="color: #04a5e5;">=</span> (index <span style="color: #04a5e5;">-</span> <span style="color: #fe640b;">112</span>) <span style="color: #04a5e5;">`mod`</span> <span style="color: #fe640b;">22</span>

  <span style="color: #9ca0b0; font-style: italic;">-- | Shorcut the enumeration for minor and major cards separately to ease the</span>
  <span style="color: #9ca0b0; font-style: italic;">-- math burden some.</span>
  fromEnum (<span style="color: #8839ef;">MinorCard</span> rank suit reversed)
    <span style="color: #04a5e5;">=</span> fromEnum rank
    <span style="color: #04a5e5;">+</span> fromEnum suit <span style="color: #04a5e5;">*</span> <span style="color: #fe640b;">14</span>
    <span style="color: #04a5e5;">+</span> fromEnum reversed <span style="color: #04a5e5;">*</span> <span style="color: #fe640b;">56</span>
  fromEnum (<span style="color: #8839ef;">MajorCard</span> arcana reversed)
    <span style="color: #04a5e5;">=</span> <span style="color: #fe640b;">112</span>
    <span style="color: #04a5e5;">+</span> fromEnum arcana
    <span style="color: #04a5e5;">+</span> fromEnum reversed <span style="color: #04a5e5;">*</span> <span style="color: #fe640b;">22</span>

  <span style="color: #9ca0b0; font-style: italic;">-- | Add the canonical boundaries to the enumerate commands to prevent errors</span>
  enumFrom x <span style="color: #04a5e5;">=</span> enumFromTo x maxBound
  enumFromThen x y <span style="color: #04a5e5;">=</span> enumFromThenTo x y bound
    <span style="color: #8839ef;">where</span>
      bound <span style="color: #04a5e5;">|</span> fromEnum y <span style="color: #04a5e5;">&gt;=</span> fromEnum x <span style="color: #04a5e5;">=</span> maxBound
            <span style="color: #04a5e5;">|</span> otherwise                <span style="color: #04a5e5;">=</span> minBound

<span style="color: #9ca0b0; font-style: italic;">-- | Set the minimum and maximum bounds to those of the minor and major arcana cards, respectively</span>
<span style="color: #8839ef;">instance</span> <span style="color: #df8e1d;">Bounded</span> <span style="color: #df8e1d;">Tarot</span> <span style="color: #8839ef;">where</span>
  minBound <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">MinorCard</span> minBound minBound minBound
  maxBound <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">MajorCard</span> maxBound maxBound
</pre>
</div>

<p>
Tarot cards need a special function for the <b>Show</b> typeclass. We can construct a simple one based on their actual type names:
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org1ec6416"><span style="color: #9ca0b0; font-style: italic;">-- | Show instance of 'Tarot' for pretty printing.</span>
<span style="color: #8839ef;">instance</span> <span style="color: #df8e1d;">Show</span> <span style="color: #df8e1d;">Tarot</span> <span style="color: #8839ef;">where</span>
  show (<span style="color: #8839ef;">MinorCard</span> rank suit <span style="color: #8839ef;">False</span>) <span style="color: #04a5e5;">=</span> show rank <span style="color: #04a5e5;">++</span> <span style="color: #40a02b;">" of "</span> <span style="color: #04a5e5;">++</span> show suit
  show (<span style="color: #8839ef;">MinorCard</span> rank suit <span style="color: #8839ef;">True</span>)  <span style="color: #04a5e5;">=</span> show rank <span style="color: #04a5e5;">++</span> <span style="color: #40a02b;">" of "</span> <span style="color: #04a5e5;">++</span> show suit <span style="color: #04a5e5;">++</span> <span style="color: #40a02b;">" (reversed)"</span>
  show (<span style="color: #8839ef;">MajorCard</span> arcana isReversed)
    <span style="color: #04a5e5;">|</span> isReversed <span style="color: #04a5e5;">=</span> words' (show arcana) <span style="color: #04a5e5;">++</span> <span style="color: #40a02b;">" (reversed)"</span>
    <span style="color: #04a5e5;">|</span> otherwise  <span style="color: #04a5e5;">=</span> words' (show arcana)
    <span style="color: #8839ef;">where</span>
      <span style="color: #9ca0b0; font-style: italic;">-- | words' is a helper function that will separate arcana into words</span>
      <span style="color: #9ca0b0; font-style: italic;">-- wherever there's a capital letter</span>
      words' <span style="color: #8839ef;">[]</span> <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">[]</span>
      words' (capital<span style="color: #8839ef;">:</span>rest)
        <span style="color: #04a5e5;">=</span> (capital <span style="color: #8839ef;">:</span> takeWhile isLower rest)
        <span style="color: #04a5e5;">++</span> <span style="color: #8839ef;">case</span> dropWhile isLower rest <span style="color: #8839ef;">of</span>
            <span style="color: #40a02b;">""</span> <span style="color: #04a5e5;">-&gt;</span> <span style="color: #40a02b;">""</span>
            nextCapital' <span style="color: #04a5e5;">-&gt;</span> <span style="color: #40a02b;">' '</span> <span style="color: #8839ef;">:</span> words' nextCapital'
</pre>
</div>

<p>
We can see, though, that <code>words'</code> isn&rsquo;t the standard <code>words</code> function, and will need the function <code>isLower</code> from the <code>Data.Char</code> library, which we&rsquo;ll need to include in our imports with .
</p>

<p>
With that, here&rsquo;s a demonstration of the typeclass at work:
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org60f2bc0"><span style="color: #1e66f5;">map</span> show [<span style="color: #8839ef;">MinorCard</span> <span style="color: #8839ef;">Three</span> <span style="color: #8839ef;">Wands</span> <span style="color: #8839ef;">False</span>, <span style="color: #8839ef;">MajorCard</span> <span style="color: #8839ef;">TheFool</span> <span style="color: #8839ef;">False</span>, <span style="color: #8839ef;">MajorCard</span> <span style="color: #8839ef;">TheWorld</span> <span style="color: #8839ef;">True</span>]
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org8a94b6c" class="outline-3">
<h3 id="org8a94b6c"><span class="section-number-3">2.2.</span> Randomness</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-org7182993" class="outline-4">
<h4 id="org7182993"><span class="section-number-4">2.2.1.</span> Individual Cards</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
With the structure of the completed, we can return to those strange typeclasses we defined before, <b>Uniform</b>. <b>Uniform</b> is a &ldquo;class of types for which a uniformly distributed value can be drawn from all possible values of the type&rdquo;, which pairs well for our card definitions. Using this simple implementation, we can craft some useful functions for import.
</p>

<p>
First is for getting a random Tarot card. It&rsquo;s actually simpler than fetching other variants, so we&rsquo;ll define it first.
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgb348750"><span style="color: #9ca0b0; font-style: italic;">{- | 'randomTarot' generates a random tarot card, either Minor or Major Arcana,</span>
<span style="color: #9ca0b0; font-style: italic;"> - with equal probability. The rank, suit, or card, and orientation (reversed or not)</span>
<span style="color: #9ca0b0; font-style: italic;"> - are chosen randomly.</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">randomTarot</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #df8e1d;">Tarot</span>
<span style="color: #1e66f5;">randomTarot</span> <span style="color: #04a5e5;">=</span> uniformM globalStdGen
</pre>
</div>

<p>
Here, we make use of <b>Uniform</b>&rsquo;s <code>uniformM</code> function; because we defined all the necessary typeclasses to derive <b>Uniform</b>, we have easy access to this function which will automatically create a value from an even distribution of all possible values.
</p>

<p>
In short: when you give a little work to the type-system, it can give a lot more work back to you.
</p>

<p>
For more specific types of random generation, we can also supply the function <code>uniformEnumRM</code> with a range. Due to our type-work, we can see these spelled out in the ranges provided:
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org321a0aa"><span style="color: #9ca0b0; font-style: italic;">{- | 'randomMinorCard' generates a random Minor Arcana tarot card,</span>
<span style="color: #9ca0b0; font-style: italic;"> - choosing randomly among all possible ranks, suits, and orientations (reversed or not).</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">randomMinorCard</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #df8e1d;">Tarot</span>
<span style="color: #1e66f5;">randomMinorCard</span> <span style="color: #04a5e5;">=</span> uniformEnumRM (<span style="color: #8839ef;">MinorCard</span> minBound minBound minBound, <span style="color: #8839ef;">MinorCard</span> maxBound maxBound maxBound) globalStdGen

<span style="color: #9ca0b0; font-style: italic;">{- | 'randomMajorCard' generates a random Major Arcana tarot card,</span>
<span style="color: #9ca0b0; font-style: italic;"> - choosing randomly among all possible cards and orientations (reversed or not).</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">randomMajorCard</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #df8e1d;">Tarot</span>
<span style="color: #1e66f5;">randomMajorCard</span> <span style="color: #04a5e5;">=</span> uniformEnumRM (<span style="color: #8839ef;">MajorCard</span> minBound minBound, <span style="color: #8839ef;">MajorCard</span> maxBound maxBound) globalStdGen
</pre>
</div>

<p>
Without using the type-level definitions of randomness, we&rsquo;d need to implement the same logic within functions explicitly, like so:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #9ca0b0; font-style: italic;">-- | Function for returning a random minor card,</span>
<span style="color: #9ca0b0; font-style: italic;">-- constructed from random Ranks, Suits, and reversed value.</span>
<span style="color: #1e66f5;">randomMinorCard</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #df8e1d;">Tarot</span>
<span style="color: #1e66f5;">randomMinorCard</span> <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">do</span>
  rank <span style="color: #04a5e5;">&lt;-</span> randomIO <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #df8e1d;">Rank</span>
  suit <span style="color: #04a5e5;">&lt;-</span> randomIO <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #df8e1d;">Suit</span>
  isReversed <span style="color: #04a5e5;">&lt;-</span> randomIO <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #df8e1d;">Bool</span>
  return <span style="color: #04a5e5;">$</span> <span style="color: #8839ef;">MinorArcana</span> rank suit isReversed
</pre>
</div>

<p>
While alright on its own, the application of this type of hand-written logic could build up over time, where as type-magic will work everywhere.
</p>
</div>
</div>
<div id="outline-container-org45d3cc6" class="outline-4">
<h4 id="org45d3cc6"><span class="section-number-4">2.2.2.</span> Lists</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
Our use of the <b>Uniform</b> typeclass doesn&rsquo;t end in just individual cards. We can use <code>uniformListM</code> to creates lists of <b>Uniform</b> elements, shortcutting the work needed to do tasks like generate a list of cards.
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgb507b05"><span style="color: #9ca0b0; font-style: italic;">{- | 'drawCards' generates a list of randomly chosen tarot cards.</span>
<span style="color: #9ca0b0; font-style: italic;"> - The length of the list is determined by the input argument.</span>
<span style="color: #9ca0b0; font-style: italic;"> - This function doesn't care about duplicates; for that, see `drawFromDeck`.</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">drawCards</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">Int</span> <span style="color: #04a5e5;">-&gt;</span> <span style="color: #df8e1d;">IO</span> [<span style="color: #df8e1d;">Tarot</span>]
<span style="color: #1e66f5;">drawCards</span> num <span style="color: #04a5e5;">=</span> uniformListM num globalStdGen
</pre>
</div>

<p>
Of course, this isn&rsquo;t the function we&rsquo;d actually want as our final draw card. For that, we&rsquo;d want something that pulls uniformly from the list of cards, but also doesn&rsquo;t create duplicates. For our part, we can do this by using a full, standard list of cards, then just shuffling it a bit.
</p>

<p>
First, our shuffle function, which will work rather simply by just moving cards about. Relatively expensive, I believe, but good enough to get the job done while maintaining exactly what we need: a randomizer that pays attention to the cards that have been dealt.
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org843312b"><span style="color: #9ca0b0; font-style: italic;">{- | 'shuffle' is a naive implementation of a shuffling function for a list.</span>
<span style="color: #9ca0b0; font-style: italic;"> - It takes the input list and "cuts" it at random points, adding it to the end.</span>
<span style="color: #9ca0b0; font-style: italic;"> - It does this for the lenght of the list.</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">shuffle</span> <span style="color: #04a5e5;">::</span> [a] <span style="color: #04a5e5;">-&gt;</span> <span style="color: #df8e1d;">IO</span> [a]
<span style="color: #1e66f5;">shuffle</span> <span style="color: #8839ef;">[]</span>  <span style="color: #04a5e5;">=</span> return <span style="color: #8839ef;">[]</span>
<span style="color: #1e66f5;">shuffle</span> [x] <span style="color: #04a5e5;">=</span> return [x]
<span style="color: #1e66f5;">shuffle</span> xs <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">do</span>
    i <span style="color: #04a5e5;">&lt;-</span> randomRIO (<span style="color: #fe640b;">0</span>, length xs <span style="color: #04a5e5;">-</span> <span style="color: #fe640b;">1</span>)
    <span style="color: #8839ef;">let</span> (ys, zs) <span style="color: #04a5e5;">=</span> splitAt i xs
    rest <span style="color: #04a5e5;">&lt;-</span> shuffle (ys <span style="color: #04a5e5;">++</span> drop <span style="color: #fe640b;">1</span> zs)
    return <span style="color: #04a5e5;">$</span> (xs <span style="color: #04a5e5;">!!</span> i) <span style="color: #8839ef;">:</span> rest
</pre>
</div>

<p>
From here, we have some simple work to get this to shuffle a full list of cards, and deal them out as needed. It has some simple checks to ensure we don&rsquo;t pull more cards than are possible or less than we&rsquo;re capable.
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org98347de"><span style="color: #9ca0b0; font-style: italic;">{- | `drawFromDeck` generates a list of tarot cards as if drawn from a deck.</span>
<span style="color: #9ca0b0; font-style: italic;"> - It creates a list of all possible cards, then `shuffle`s the list.</span>
<span style="color: #9ca0b0; font-style: italic;"> - The input is the number of cards to draw from this deck.</span>
<span style="color: #9ca0b0; font-style: italic;"> - The function produces an error on invalid inputs:</span>
<span style="color: #9ca0b0; font-style: italic;"> -   1) an input greater than the size of the deck of all possible cards</span>
<span style="color: #9ca0b0; font-style: italic;"> -   2) a number less than 1</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">drawFromDeck</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">Int</span> <span style="color: #04a5e5;">-&gt;</span> <span style="color: #df8e1d;">IO</span> (<span style="color: #df8e1d;">Either</span> <span style="color: #df8e1d;">String</span> [<span style="color: #df8e1d;">Tarot</span>])
<span style="color: #1e66f5;">drawFromDeck</span> n
  <span style="color: #04a5e5;">|</span> n <span style="color: #04a5e5;">&lt;</span> <span style="color: #fe640b;">0</span> <span style="color: #04a5e5;">=</span> return <span style="color: #04a5e5;">$</span> <span style="color: #8839ef;">Left</span> <span style="color: #40a02b;">"Cannot draw a negative number of cards"</span>
  <span style="color: #04a5e5;">|</span> n <span style="color: #04a5e5;">&gt;</span> length fullDeck <span style="color: #04a5e5;">=</span> return <span style="color: #04a5e5;">$</span> <span style="color: #8839ef;">Left</span> <span style="color: #40a02b;">"Cannot draw more cards than the size of the deck"</span>
  <span style="color: #04a5e5;">|</span> otherwise <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">do</span>
      shuffledDeck <span style="color: #04a5e5;">&lt;-</span> shuffle fullDeck
      return <span style="color: #04a5e5;">$</span> <span style="color: #8839ef;">Right</span> <span style="color: #04a5e5;">$</span> take n shuffledDeck
  <span style="color: #8839ef;">where</span>
    fullDeck <span style="color: #04a5e5;">=</span> enumFrom minBound <span style="color: #04a5e5;">::</span> [<span style="color: #df8e1d;">Tarot</span>]
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org3da6cdb" class="outline-3">
<h3 id="org3da6cdb"><span class="section-number-3">2.3.</span> Main</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Now that all the major work is done, we have some basic scaffolding to do. We&rsquo;ll make us of the <code>OverloadedStrings</code> pragma, since we don&rsquo;t really want to think about them, and do some importing for necessary functions here as well.
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org3b82765"><span style="color: #df8e1d;">{-# LANGUAGE OverloadedStrings #-}</span>
<span style="color: #df8e1d;">{-# LANGUAGE DeriveAnyClass #-}</span>

<span style="color: #8839ef;">module</span> <span style="color: #8839ef;">Main</span>
  ( drawFromDeck
  , <span style="color: #8839ef;">Rank</span>(<span style="color: #04a5e5;">..</span>)
  , <span style="color: #8839ef;">Suit</span>(<span style="color: #04a5e5;">..</span>)
  , <span style="color: #8839ef;">MajorArcana</span>(<span style="color: #04a5e5;">..</span>)
  , <span style="color: #8839ef;">Tarot</span>(<span style="color: #04a5e5;">..</span>)
  , randomMinorCard
  , randomMajorCard
  , randomTarot
  , main
  ) <span style="color: #8839ef;">where</span>

<span style="color: #8839ef;">import</span> <span style="color: #8839ef;">Data.Char</span>     (isLower)
<span style="color: #8839ef;">import</span> <span style="color: #8839ef;">System.IO</span>     (hFlush,stdout)
<span style="color: #8839ef;">import</span> <span style="color: #8839ef;">System.Random.Stateful</span>
<span style="color: #8839ef;">import</span> <span style="color: #8839ef;">GHC.Generics</span>  (<span style="color: #8839ef;">Generic</span>)

<span style="color: #9ca0b0; font-style: italic;">{- | 'Rank' defines the 14 possible ranks of the minor arcana,</span>
<span style="color: #9ca0b0; font-style: italic;"> - 10 pip cards and 4 court/face cards.</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #8839ef;">data</span> <span style="color: #df8e1d;">Rank</span>
  <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">Ace</span>   <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Two</span>    <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Three</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Four</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Five</span>
  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Six</span>   <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Seven</span>  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Eight</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Nine</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Ten</span>
  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Paige</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Knight</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Queen</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">King</span>
  <span style="color: #9ca0b0; font-style: italic;">-- | Ranks are bounded, sequenced, finite, and have uniform distribution.</span>
  <span style="color: #9ca0b0; font-style: italic;">-- Deriving these classes allow us to have type-level functions for getting random elements,</span>
  <span style="color: #9ca0b0; font-style: italic;">-- a theme we'll repeat with other typeclasses.</span>
  <span style="color: #8839ef;">deriving</span> (<span style="color: #8839ef;">Bounded</span>, <span style="color: #8839ef;">Enum</span>, <span style="color: #8839ef;">Eq</span>, <span style="color: #8839ef;">Ord</span>, <span style="color: #8839ef;">Show</span>, <span style="color: #8839ef;">Generic</span>, <span style="color: #8839ef;">Finite</span>, <span style="color: #8839ef;">Uniform</span>)

<span style="color: #9ca0b0; font-style: italic;">-- | 'Suit' defines the possible suits for the minor arcana.</span>
<span style="color: #8839ef;">data</span> <span style="color: #df8e1d;">Suit</span> <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">Wands</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Cups</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Swords</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Pentacles</span>
  <span style="color: #8839ef;">deriving</span> (<span style="color: #8839ef;">Bounded</span>, <span style="color: #8839ef;">Enum</span>, <span style="color: #8839ef;">Eq</span>, <span style="color: #8839ef;">Show</span>, <span style="color: #8839ef;">Generic</span>, <span style="color: #8839ef;">Finite</span>, <span style="color: #8839ef;">Uniform</span>)

<span style="color: #9ca0b0; font-style: italic;">-- | 'MajorArcana' defines the 22 major arcana.</span>
<span style="color: #8839ef;">data</span> <span style="color: #df8e1d;">MajorArcana</span>
  <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">TheFool</span>        <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheMagician</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheHighPriestess</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheEmpress</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheEmperor</span>
  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheHierophant</span>  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheLovers</span>   <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheChariot</span>       <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Strength</span>   <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheHermit</span>
  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">WheelOfFortune</span> <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Justice</span>     <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheHangedMan</span>     <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Death</span>      <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Temperance</span>
  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheDevil</span>       <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheTower</span>    <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheStar</span>          <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheMoon</span>    <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheSun</span>
  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">Judgement</span>      <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">TheWorld</span>
  <span style="color: #8839ef;">deriving</span> (<span style="color: #8839ef;">Eq</span>, <span style="color: #8839ef;">Enum</span>, <span style="color: #8839ef;">Show</span>, <span style="color: #8839ef;">Bounded</span>, <span style="color: #8839ef;">Generic</span>, <span style="color: #8839ef;">Finite</span>, <span style="color: #8839ef;">Uniform</span>)

<span style="color: #9ca0b0; font-style: italic;">{- | 'Tarot' has two kinds, for minor and major arcana, as well as a bool for</span>
<span style="color: #9ca0b0; font-style: italic;"> - representing when the card is reversed.</span>
<span style="color: #9ca0b0; font-style: italic;"> - 'Minor' has rank, suit, and reversed status.</span>
<span style="color: #9ca0b0; font-style: italic;"> - 'Major' has the major arcana and the reversed status.</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #8839ef;">data</span> <span style="color: #df8e1d;">Tarot</span>
  <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">MinorCard</span> <span style="color: #8839ef;">Rank</span> <span style="color: #8839ef;">Suit</span> <span style="color: #8839ef;">Bool</span>
  <span style="color: #04a5e5;">|</span> <span style="color: #8839ef;">MajorCard</span> <span style="color: #8839ef;">MajorArcana</span> <span style="color: #8839ef;">Bool</span>
  <span style="color: #8839ef;">deriving</span> (<span style="color: #8839ef;">Eq</span>, <span style="color: #8839ef;">Generic</span>, <span style="color: #8839ef;">Finite</span>, <span style="color: #8839ef;">Uniform</span>)

<span style="color: #9ca0b0; font-style: italic;">{- | Enumeration rules for tarot cards:</span>
<span style="color: #9ca0b0; font-style: italic;"> - Minor Arcana =&gt; 14 Ranks * 4 Suits * 2 Reversed states = 112 values</span>
<span style="color: #9ca0b0; font-style: italic;"> - Major Arcana =&gt; 22 arcana * 2 Reversed states = 44 values</span>
<span style="color: #9ca0b0; font-style: italic;"> - total: 156</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #8839ef;">instance</span> <span style="color: #df8e1d;">Enum</span> <span style="color: #df8e1d;">Tarot</span> <span style="color: #8839ef;">where</span>
  toEnum index
    <span style="color: #04a5e5;">|</span> index <span style="color: #04a5e5;">&lt;</span> <span style="color: #fe640b;">0</span> <span style="color: #04a5e5;">||</span> <span style="color: #fe640b;">156</span> <span style="color: #04a5e5;">&lt;=</span> index <span style="color: #04a5e5;">=</span> error <span style="color: #40a02b;">"Out of bounds for Tarot cards"</span>
    <span style="color: #04a5e5;">|</span> index <span style="color: #04a5e5;">&lt;</span> <span style="color: #fe640b;">112</span> <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">MinorCard</span> (toEnum rank) (toEnum suit) (toEnum reversed)
    <span style="color: #04a5e5;">|</span> <span style="color: #fe640b;">112</span> <span style="color: #04a5e5;">&lt;=</span> index <span style="color: #04a5e5;">&amp;&amp;</span> index <span style="color: #04a5e5;">&lt;</span> <span style="color: #fe640b;">134</span> <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">MajorCard</span> (toEnum arcana) <span style="color: #8839ef;">False</span>
    <span style="color: #04a5e5;">|</span> otherwise <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">MajorCard</span> (toEnum arcana) <span style="color: #8839ef;">True</span>
    <span style="color: #8839ef;">where</span>
      (index', rank) <span style="color: #04a5e5;">=</span> index <span style="color: #04a5e5;">`divMod`</span> <span style="color: #fe640b;">14</span>
      (reversed, suit) <span style="color: #04a5e5;">=</span> index' <span style="color: #04a5e5;">`divMod`</span> <span style="color: #fe640b;">4</span>
      arcana <span style="color: #04a5e5;">=</span> (index <span style="color: #04a5e5;">-</span> <span style="color: #fe640b;">112</span>) <span style="color: #04a5e5;">`mod`</span> <span style="color: #fe640b;">22</span>

  <span style="color: #9ca0b0; font-style: italic;">-- | Shorcut the enumeration for minor and major cards separately to ease the</span>
  <span style="color: #9ca0b0; font-style: italic;">-- math burden some.</span>
  fromEnum (<span style="color: #8839ef;">MinorCard</span> rank suit reversed)
    <span style="color: #04a5e5;">=</span> fromEnum rank
    <span style="color: #04a5e5;">+</span> fromEnum suit <span style="color: #04a5e5;">*</span> <span style="color: #fe640b;">14</span>
    <span style="color: #04a5e5;">+</span> fromEnum reversed <span style="color: #04a5e5;">*</span> <span style="color: #fe640b;">56</span>
  fromEnum (<span style="color: #8839ef;">MajorCard</span> arcana reversed)
    <span style="color: #04a5e5;">=</span> <span style="color: #fe640b;">112</span>
    <span style="color: #04a5e5;">+</span> fromEnum arcana
    <span style="color: #04a5e5;">+</span> fromEnum reversed <span style="color: #04a5e5;">*</span> <span style="color: #fe640b;">22</span>

  <span style="color: #9ca0b0; font-style: italic;">-- | Add the canonical boundaries to the enumerate commands to prevent errors</span>
  enumFrom x <span style="color: #04a5e5;">=</span> enumFromTo x maxBound
  enumFromThen x y <span style="color: #04a5e5;">=</span> enumFromThenTo x y bound
    <span style="color: #8839ef;">where</span>
      bound <span style="color: #04a5e5;">|</span> fromEnum y <span style="color: #04a5e5;">&gt;=</span> fromEnum x <span style="color: #04a5e5;">=</span> maxBound
            <span style="color: #04a5e5;">|</span> otherwise                <span style="color: #04a5e5;">=</span> minBound

<span style="color: #9ca0b0; font-style: italic;">-- | Set the minimum and maximum bounds to those of the minor and major arcana cards, respectively</span>
<span style="color: #8839ef;">instance</span> <span style="color: #df8e1d;">Bounded</span> <span style="color: #df8e1d;">Tarot</span> <span style="color: #8839ef;">where</span>
  minBound <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">MinorCard</span> minBound minBound minBound
  maxBound <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">MajorCard</span> maxBound maxBound

<span style="color: #9ca0b0; font-style: italic;">-- | Show instance of 'Tarot' for pretty printing.</span>
<span style="color: #8839ef;">instance</span> <span style="color: #df8e1d;">Show</span> <span style="color: #df8e1d;">Tarot</span> <span style="color: #8839ef;">where</span>
  show (<span style="color: #8839ef;">MinorCard</span> rank suit <span style="color: #8839ef;">False</span>) <span style="color: #04a5e5;">=</span> show rank <span style="color: #04a5e5;">++</span> <span style="color: #40a02b;">" of "</span> <span style="color: #04a5e5;">++</span> show suit
  show (<span style="color: #8839ef;">MinorCard</span> rank suit <span style="color: #8839ef;">True</span>)  <span style="color: #04a5e5;">=</span> show rank <span style="color: #04a5e5;">++</span> <span style="color: #40a02b;">" of "</span> <span style="color: #04a5e5;">++</span> show suit <span style="color: #04a5e5;">++</span> <span style="color: #40a02b;">" (reversed)"</span>
  show (<span style="color: #8839ef;">MajorCard</span> arcana isReversed)
    <span style="color: #04a5e5;">|</span> isReversed <span style="color: #04a5e5;">=</span> words' (show arcana) <span style="color: #04a5e5;">++</span> <span style="color: #40a02b;">" (reversed)"</span>
    <span style="color: #04a5e5;">|</span> otherwise  <span style="color: #04a5e5;">=</span> words' (show arcana)
    <span style="color: #8839ef;">where</span>
      <span style="color: #9ca0b0; font-style: italic;">-- | words' is a helper function that will separate arcana into words</span>
      <span style="color: #9ca0b0; font-style: italic;">-- wherever there's a capital letter</span>
      words' <span style="color: #8839ef;">[]</span> <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">[]</span>
      words' (capital<span style="color: #8839ef;">:</span>rest)
        <span style="color: #04a5e5;">=</span> (capital <span style="color: #8839ef;">:</span> takeWhile isLower rest)
        <span style="color: #04a5e5;">++</span> <span style="color: #8839ef;">case</span> dropWhile isLower rest <span style="color: #8839ef;">of</span>
            <span style="color: #40a02b;">""</span> <span style="color: #04a5e5;">-&gt;</span> <span style="color: #40a02b;">""</span>
            nextCapital' <span style="color: #04a5e5;">-&gt;</span> <span style="color: #40a02b;">' '</span> <span style="color: #8839ef;">:</span> words' nextCapital'

<span style="color: #9ca0b0; font-style: italic;">{- | 'randomTarot' generates a random tarot card, either Minor or Major Arcana,</span>
<span style="color: #9ca0b0; font-style: italic;"> - with equal probability. The rank, suit, or card, and orientation (reversed or not)</span>
<span style="color: #9ca0b0; font-style: italic;"> - are chosen randomly.</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">randomTarot</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #df8e1d;">Tarot</span>
<span style="color: #1e66f5;">randomTarot</span> <span style="color: #04a5e5;">=</span> uniformM globalStdGen

<span style="color: #9ca0b0; font-style: italic;">{- | 'randomMinorCard' generates a random Minor Arcana tarot card,</span>
<span style="color: #9ca0b0; font-style: italic;"> - choosing randomly among all possible ranks, suits, and orientations (reversed or not).</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">randomMinorCard</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #df8e1d;">Tarot</span>
<span style="color: #1e66f5;">randomMinorCard</span> <span style="color: #04a5e5;">=</span> uniformEnumRM (<span style="color: #8839ef;">MinorCard</span> minBound minBound minBound, <span style="color: #8839ef;">MinorCard</span> maxBound maxBound maxBound) globalStdGen

<span style="color: #9ca0b0; font-style: italic;">{- | 'randomMajorCard' generates a random Major Arcana tarot card,</span>
<span style="color: #9ca0b0; font-style: italic;"> - choosing randomly among all possible cards and orientations (reversed or not).</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">randomMajorCard</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #df8e1d;">Tarot</span>
<span style="color: #1e66f5;">randomMajorCard</span> <span style="color: #04a5e5;">=</span> uniformEnumRM (<span style="color: #8839ef;">MajorCard</span> minBound minBound, <span style="color: #8839ef;">MajorCard</span> maxBound maxBound) globalStdGen

<span style="color: #9ca0b0; font-style: italic;">{- | 'drawCards' generates a list of randomly chosen tarot cards.</span>
<span style="color: #9ca0b0; font-style: italic;"> - The length of the list is determined by the input argument.</span>
<span style="color: #9ca0b0; font-style: italic;"> - This function doesn't care about duplicates; for that, see `drawFromDeck`.</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">drawCards</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">Int</span> <span style="color: #04a5e5;">-&gt;</span> <span style="color: #df8e1d;">IO</span> [<span style="color: #df8e1d;">Tarot</span>]
<span style="color: #1e66f5;">drawCards</span> num <span style="color: #04a5e5;">=</span> uniformListM num globalStdGen

<span style="color: #9ca0b0; font-style: italic;">{- | 'shuffle' is a naive implementation of a shuffling function for a list.</span>
<span style="color: #9ca0b0; font-style: italic;"> - It takes the input list and "cuts" it at random points, adding it to the end.</span>
<span style="color: #9ca0b0; font-style: italic;"> - It does this for the lenght of the list.</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">shuffle</span> <span style="color: #04a5e5;">::</span> [a] <span style="color: #04a5e5;">-&gt;</span> <span style="color: #df8e1d;">IO</span> [a]
<span style="color: #1e66f5;">shuffle</span> <span style="color: #8839ef;">[]</span>  <span style="color: #04a5e5;">=</span> return <span style="color: #8839ef;">[]</span>
<span style="color: #1e66f5;">shuffle</span> [x] <span style="color: #04a5e5;">=</span> return [x]
<span style="color: #1e66f5;">shuffle</span> xs <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">do</span>
    i <span style="color: #04a5e5;">&lt;-</span> randomRIO (<span style="color: #fe640b;">0</span>, length xs <span style="color: #04a5e5;">-</span> <span style="color: #fe640b;">1</span>)
    <span style="color: #8839ef;">let</span> (ys, zs) <span style="color: #04a5e5;">=</span> splitAt i xs
    rest <span style="color: #04a5e5;">&lt;-</span> shuffle (ys <span style="color: #04a5e5;">++</span> drop <span style="color: #fe640b;">1</span> zs)
    return <span style="color: #04a5e5;">$</span> (xs <span style="color: #04a5e5;">!!</span> i) <span style="color: #8839ef;">:</span> rest

<span style="color: #9ca0b0; font-style: italic;">{- | `drawFromDeck` generates a list of tarot cards as if drawn from a deck.</span>
<span style="color: #9ca0b0; font-style: italic;"> - It creates a list of all possible cards, then `shuffle`s the list.</span>
<span style="color: #9ca0b0; font-style: italic;"> - The input is the number of cards to draw from this deck.</span>
<span style="color: #9ca0b0; font-style: italic;"> - The function produces an error on invalid inputs:</span>
<span style="color: #9ca0b0; font-style: italic;"> -   1) an input greater than the size of the deck of all possible cards</span>
<span style="color: #9ca0b0; font-style: italic;"> -   2) a number less than 1</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">drawFromDeck</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">Int</span> <span style="color: #04a5e5;">-&gt;</span> <span style="color: #df8e1d;">IO</span> (<span style="color: #df8e1d;">Either</span> <span style="color: #df8e1d;">String</span> [<span style="color: #df8e1d;">Tarot</span>])
<span style="color: #1e66f5;">drawFromDeck</span> n
  <span style="color: #04a5e5;">|</span> n <span style="color: #04a5e5;">&lt;</span> <span style="color: #fe640b;">0</span> <span style="color: #04a5e5;">=</span> return <span style="color: #04a5e5;">$</span> <span style="color: #8839ef;">Left</span> <span style="color: #40a02b;">"Cannot draw a negative number of cards"</span>
  <span style="color: #04a5e5;">|</span> n <span style="color: #04a5e5;">&gt;</span> length fullDeck <span style="color: #04a5e5;">=</span> return <span style="color: #04a5e5;">$</span> <span style="color: #8839ef;">Left</span> <span style="color: #40a02b;">"Cannot draw more cards than the size of the deck"</span>
  <span style="color: #04a5e5;">|</span> otherwise <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">do</span>
      shuffledDeck <span style="color: #04a5e5;">&lt;-</span> shuffle fullDeck
      return <span style="color: #04a5e5;">$</span> <span style="color: #8839ef;">Right</span> <span style="color: #04a5e5;">$</span> take n shuffledDeck
  <span style="color: #8839ef;">where</span>
    fullDeck <span style="color: #04a5e5;">=</span> enumFrom minBound <span style="color: #04a5e5;">::</span> [<span style="color: #df8e1d;">Tarot</span>]

<span style="color: #9ca0b0; font-style: italic;">{- | 'ordinal' takes an integer and returns its ordinal representation as a string.</span>
<span style="color: #9ca0b0; font-style: italic;"> - For example, 'ordinal 3' returns "3rd".</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">ordinal</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">Int</span> <span style="color: #04a5e5;">-&gt;</span> <span style="color: #df8e1d;">String</span>
<span style="color: #1e66f5;">ordinal</span> <span style="color: #fe640b;">11</span> <span style="color: #04a5e5;">=</span> <span style="color: #40a02b;">"11th"</span>
<span style="color: #1e66f5;">ordinal</span> <span style="color: #fe640b;">12</span> <span style="color: #04a5e5;">=</span> <span style="color: #40a02b;">"12th"</span>
<span style="color: #1e66f5;">ordinal</span> <span style="color: #fe640b;">13</span> <span style="color: #04a5e5;">=</span> <span style="color: #40a02b;">"13th"</span>
<span style="color: #1e66f5;">ordinal</span> index <span style="color: #04a5e5;">=</span> show index <span style="color: #04a5e5;">++</span> <span style="color: #8839ef;">case</span> (last <span style="color: #04a5e5;">$</span> show index) <span style="color: #8839ef;">of</span>
  <span style="color: #40a02b;">'1'</span> <span style="color: #04a5e5;">-&gt;</span> <span style="color: #40a02b;">"st"</span>
  <span style="color: #40a02b;">'2'</span> <span style="color: #04a5e5;">-&gt;</span> <span style="color: #40a02b;">"nd"</span>
  <span style="color: #40a02b;">'3'</span> <span style="color: #04a5e5;">-&gt;</span> <span style="color: #40a02b;">"rd"</span>
  <span style="color: #8839ef;">_</span>   <span style="color: #04a5e5;">-&gt;</span> <span style="color: #40a02b;">"th"</span>

<span style="color: #9ca0b0; font-style: italic;">{- | The 'main' function prompts the user for a number of cards to draw,</span>
<span style="color: #9ca0b0; font-style: italic;"> - then generates and prints that many random tarot cards.</span>
<span style="color: #9ca0b0; font-style: italic;"> - Each card is printed with its position in the draw (1st, 2nd, etc.) and its details.</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">main</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #8839ef;">()</span>
<span style="color: #1e66f5;">main</span> <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">do</span>
  putStr <span style="color: #40a02b;">"How many cards shall I draw? "</span>
  hFlush stdout
  numberOfCards <span style="color: #04a5e5;">&lt;-</span> readLn <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #df8e1d;">Int</span>
  cards <span style="color: #04a5e5;">&lt;-</span> drawCards numberOfCards
  mapM_ printOrderCard <span style="color: #04a5e5;">$</span> zip [<span style="color: #fe640b;">1</span><span style="color: #04a5e5;">..</span>] cards
  <span style="color: #8839ef;">where</span>
    printOrderCard (index,card) <span style="color: #04a5e5;">=</span> putStrLn <span style="color: #04a5e5;">$</span> ordinal index <span style="color: #04a5e5;">++</span> <span style="color: #40a02b;">": "</span> <span style="color: #04a5e5;">++</span> show card
</pre>
</div>

<p>
Last but not least, we have the actual main entry into the program, the CLI, and a little housekeeping function to keep our output clean.
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org5b46f58"><span style="color: #9ca0b0; font-style: italic;">{- | 'ordinal' takes an integer and returns its ordinal representation as a string.</span>
<span style="color: #9ca0b0; font-style: italic;"> - For example, 'ordinal 3' returns "3rd".</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">ordinal</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">Int</span> <span style="color: #04a5e5;">-&gt;</span> <span style="color: #df8e1d;">String</span>
<span style="color: #1e66f5;">ordinal</span> <span style="color: #fe640b;">11</span> <span style="color: #04a5e5;">=</span> <span style="color: #40a02b;">"11th"</span>
<span style="color: #1e66f5;">ordinal</span> <span style="color: #fe640b;">12</span> <span style="color: #04a5e5;">=</span> <span style="color: #40a02b;">"12th"</span>
<span style="color: #1e66f5;">ordinal</span> <span style="color: #fe640b;">13</span> <span style="color: #04a5e5;">=</span> <span style="color: #40a02b;">"13th"</span>
<span style="color: #1e66f5;">ordinal</span> index <span style="color: #04a5e5;">=</span> show index <span style="color: #04a5e5;">++</span> <span style="color: #8839ef;">case</span> (last <span style="color: #04a5e5;">$</span> show index) <span style="color: #8839ef;">of</span>
  <span style="color: #40a02b;">'1'</span> <span style="color: #04a5e5;">-&gt;</span> <span style="color: #40a02b;">"st"</span>
  <span style="color: #40a02b;">'2'</span> <span style="color: #04a5e5;">-&gt;</span> <span style="color: #40a02b;">"nd"</span>
  <span style="color: #40a02b;">'3'</span> <span style="color: #04a5e5;">-&gt;</span> <span style="color: #40a02b;">"rd"</span>
  <span style="color: #8839ef;">_</span>   <span style="color: #04a5e5;">-&gt;</span> <span style="color: #40a02b;">"th"</span>

<span style="color: #9ca0b0; font-style: italic;">{- | The 'main' function prompts the user for a number of cards to draw,</span>
<span style="color: #9ca0b0; font-style: italic;"> - then generates and prints that many random tarot cards.</span>
<span style="color: #9ca0b0; font-style: italic;"> - Each card is printed with its position in the draw (1st, 2nd, etc.) and its details.</span>
<span style="color: #9ca0b0; font-style: italic;"> -}</span>
<span style="color: #1e66f5;">main</span> <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #8839ef;">()</span>
<span style="color: #1e66f5;">main</span> <span style="color: #04a5e5;">=</span> <span style="color: #8839ef;">do</span>
  putStr <span style="color: #40a02b;">"How many cards shall I draw? "</span>
  hFlush stdout
  numberOfCards <span style="color: #04a5e5;">&lt;-</span> readLn <span style="color: #04a5e5;">::</span> <span style="color: #df8e1d;">IO</span> <span style="color: #df8e1d;">Int</span>
  cards <span style="color: #04a5e5;">&lt;-</span> drawCards numberOfCards
  mapM_ printOrderCard <span style="color: #04a5e5;">$</span> zip [<span style="color: #fe640b;">1</span><span style="color: #04a5e5;">..</span>] cards
  <span style="color: #8839ef;">where</span>
    printOrderCard (index,card) <span style="color: #04a5e5;">=</span> putStrLn <span style="color: #04a5e5;">$</span> ordinal index <span style="color: #04a5e5;">++</span> <span style="color: #40a02b;">": "</span> <span style="color: #04a5e5;">++</span> show card
</pre>
</div>

<p>
And that&rsquo;s it! The program can be called and ran from CLI, and will run simply draw the number of cards requested.
</p>

<pre class="example" id="org32d6b8d">
$ tarot
How many cards shall I draw? 3
1st: Nine of Swords (reversed)
2nd: Ten of Cups
3rd: Ace of Wands
</pre>
</div>
</div>
</div>
<div id="outline-container-org247abf8" class="outline-2">
<h2 id="org247abf8"><span class="section-number-2">3.</span> Afterword</h2>
<div class="outline-text-2" id="text-3">
<p>
This was a tiny project to explore making use of two particular paradigms I&rsquo;m not used to: Literate Programming, and Type-Driven Development. I find both ideas fascinating, but have been struggling to actually find time or try to actually make use of them, so I&rsquo;ve forced myself to write out a common idea in Haskell using LP and T(ype)DD, and I believe it&rsquo;s mostly effective. I&rsquo;ll say that the biggest issues I faced were adjusting to learning how to write out my ideas as I include the code into the project, and how best to work with types at the forefront and not as an afterthought.
</p>

<p>
The literate part of Literate Programming was harder than I expected. Not because of documenting the code as I expected it would (it came more naturally than I expected to include code in the docs and the literate source), but because of the context changing between them. I found myself moving away from the more standard cycle of Experiment =&gt; Find Failure =&gt; Experiment =&gt; Find Success =&gt; Commit, to instead reasoning more about what exactly I was attempting to write and why, and how to make that reality simple enough for consumption in the literate source. Maybe this was just part of creating a project that might see the light of day off of my SSD for the first time, or maybe it was the result of actually following the Literate Programming ideals and hitting the natural strides of trying to explain the reasoning <i>as you&rsquo;re writing it</i>.
</p>

<p>
Either way, I feel better about Literate Programming as a result. It&rsquo;s definitely more cumbersome than just loading up a source file and editing it, but I feel more agile about it with practice, and I do believe that the extra effort may be worth it. Not totally proven correct there, yet, but we&rsquo;ll see.
</p>

<p>
As for Type-Driven Development, I still feel like I&rsquo;ve made some mistakes here, moreso than just with the LP part of the project. The cumbersome way that <b>Uniform</b> is attached to the typeclasses by deriving <b>Generic</b> feels heavy, even if its just a library import, and the fact that I don&rsquo;t use it&rsquo;s power in the main function (<code>drawFromDeck</code>) feels like I&rsquo;ve missed something. Worse yet, I&rsquo;m not sure if this was the wrong decision: I <i>prefer</i> using <b>Uniform</b> over manually writing out the randomness logic, and I believe it&rsquo;s due to wanting to incorporate more type logic, not less.
</p>

<p>
With that in mind, I think I should focus more on types in the future as Haskell incorporates more features on Dependent Types, just to be able to use them more effectively.
</p>

<p>
Glad to have actually written this project, by these measures. Worth learning, though we&rsquo;ll see if I actually ever publish this anywhere.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2024-10-26</p>
<p class="author">Author: Jordan Bell</p>
<p class="date">Created: 2024-12-15 Sun 23:55</p>
</div>
</body>
</html>
